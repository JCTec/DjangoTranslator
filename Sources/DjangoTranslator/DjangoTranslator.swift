import Fluent
import Foundation
import Vapor

public struct PyImport {
    public let val: String
    
    public init(_ val: String) {
        self.val = val
    }
    
    public func line() -> String {
        return "import \(val)\n"
    }
}

public struct ModelAdmin {
    public let className: String
    public let searchFields: [String]?
    public let dateHierarchy: String?

    public init(className: String, searchFields: [String]? = nil, dateHierarchy: String? = nil) {
        self.className = className
        self.searchFields = searchFields
        self.dateHierarchy = dateHierarchy
    }
    
    public func lines() -> String {
        var shouldAddPass = true
        
        var str = "class \(className)(admin.ModelAdmin):\n"
        
        if let searchFields = searchFields {
            shouldAddPass = false
            str += "    search_fields = ('\(searchFields.joined(separator: "', '"))',)\n"
        }
        
        if let dateHierarchy = dateHierarchy {
            shouldAddPass = false
            str += "    date_hierarchy = \(dateHierarchy)\n"
        }
        
        if shouldAddPass {
            str += "    pass\n"
        }
        
        str += "\n"
        
        return str
    }
}

public protocol DjangoTranslatableKeys {
    init()
}

public protocol DjangoTranslatable {
    var className: String { get }
    var tableName: String { get }
    var orderingArray: [String]? { get }
    var verboseNamePlural: String? { get }
    var strDefinition: String? { get }
    func getTranslation() -> DjangoTranslatableKeys
    func getModelAdmin() -> ModelAdmin?
}

public extension DjangoTranslatable {
    var orderingArray: [String]? {
        nil
    }
    
    var strDefinition: String? {
        nil
    }
    
    var verboseNamePlural: String? {
        nil
    }
    
    func getModelAdmin() -> ModelAdmin? {
        nil
    }
}

public class DjangoTranslator {
    private let name = "DjangoBuddy"
    public let siteHeader: String
    public let siteTitle: String
    public let indexTitle: String
    
    private var djangoTranslatables = [DjangoTranslatable]()
    
    private var modelPyImports = [
        PyImport("uuid"),
        PyImport("from django.db import models")
    ]
    
    private var adminPyImports = [
        PyImport("from django.contrib import admin"),
        PyImport("from .models import *"),
    ]
    
    private var extraAdminArguments: String = "# No Extra Arguments"
    
    public init(siteHeader: String = "Vapor API", siteTitle: String = "Vapor Admin Portal", indexTitle: String = "Welcome to the Vapor Admin Portal") {
        self.siteHeader = siteHeader
        self.siteTitle = siteTitle
        self.indexTitle = indexTitle
    }
        
    public func register(_ service: DjangoTranslatable) {
        djangoTranslatables.append(service)
    }
    
    public func set(extraAdminArguments: String) {
        self.extraAdminArguments = extraAdminArguments
    }
    
    public func addModels(pyImport: PyImport) {
        modelPyImports.append(pyImport)
    }
    
    public func addAdmins(pyImport: PyImport) {
        adminPyImports.append(pyImport)
    }
    
    public func managePyExists() -> Bool {
        let managePyPath = FileManager
                            .documentsDirecotry
                            .appendingPathComponent(name)
                            .appendingPathComponent("manage.py", isDirectory: false)
        
        return FileManager.default.fileExists(atPath: managePyPath.path)
    }
    
    public func copyMainSource() throws {
        let djangoBuddyDirectory = FileManager
                                        .djangoBuddyDirectory
        
        let documentsDirecotry = FileManager
                                    .documentsDirecotry
                                    .appendingPathComponent(name, isDirectory: true)
        
        do {
            print(try FileManager.default.copyFiles(from: djangoBuddyDirectory, to: documentsDirecotry))
        } catch {
            print(error)
        }
    }
    
    public func removeSource() throws {
        let documentsDirecotry = FileManager
                                    .documentsDirecotry
                                    .appendingPathComponent(name, isDirectory: true)
        
        if FileManager.default.fileExists(atPath: documentsDirecotry.path) {
            try FileManager.default.removeItem(atPath: documentsDirecotry.path)
        }
    }
    
    public func generateAdminPyFileString() -> String {
        var adminsPy = "# Admin.py Autogenerated by DjangoTranslator\n"
        
        for pyImport in adminPyImports {
            adminsPy += pyImport.line()
        }
        
        adminsPy += "\n"
        
        adminsPy += "# Extra Admin Arguments --------------\n"
        adminsPy += extraAdminArguments.appending("\n")
        adminsPy += "#-------------------------------------\n\n\n"

        for service in djangoTranslatables {
            if let lines = service.getModelAdmin()?.lines() {
                adminsPy += lines
            }
        }
        
        adminsPy += "\n"

        for service in djangoTranslatables {
            if let modelAdmin = service.getModelAdmin() {
                adminsPy += "admin.site.register(\(service.className), \(modelAdmin.className))\n"
            } else {
                adminsPy += "admin.site.register(\(service.className))\n"
            }
        }
        
        adminsPy += "\n"
        
        adminsPy += "admin.site.site_header = '\(siteHeader)'\n"
        adminsPy += "admin.site.site_title = '\(siteTitle)'\n"
        adminsPy += "admin.site.index_title = '\(indexTitle)'\n"

        adminsPy += "\n"

        return adminsPy
    }
    
    public func generateModelPyFileString() -> String {
        var modelsPy = "# Models.py Autogenerated by DjangoTranslator\n"
        
        for pyImport in modelPyImports {
            modelsPy += pyImport.line()
        }
        
        modelsPy += "\n"
        
        for service in djangoTranslatables {
            let children = Mirror(reflecting: service.getTranslation()).children

            modelsPy += "class \(service.className)(models.Model):\n"
            
            for child in children {
                modelsPy += "    \(child.label ?? "Error") = \(child.value)\n"
            }
            
            modelsPy += "\n"
            modelsPy += "    class Meta(object):\n"
            modelsPy += "        db_table = '\(service.tableName)'\n"
            modelsPy += "        managed = False\n"

            if let orderingArray = service.orderingArray {
                modelsPy += "        ordering = ['\(orderingArray.joined(separator: "', '"))']\n"
            }
                        
            if let verboseNamePlural = service.verboseNamePlural {
                modelsPy += "        verbose_name_plural = '\(verboseNamePlural)'\n"
            }
            
            if let strDefinition = service.strDefinition {
                modelsPy += "    def __str__(self):\n"
                modelsPy += "        return \(strDefinition)\n"
            }
            
            modelsPy += "\n"

        }
        
        return modelsPy
    }
    
    public func writeModelsPyFromServices() {
        let modelsPyFile = FileManager
                            .documentsDirecotry
                            .appendingPathComponent(name, isDirectory: true)
                            .appendingPathComponent("api", isDirectory: true)
                            .appendingPathComponent("models.py", isDirectory: false)
        
        do {
            try generateModelPyFileString().write(toFile: modelsPyFile.path, atomically: true, encoding: String.Encoding.utf8)
        } catch {
            print(error)
        }
    }
    
    public func writeAdminPyFromServices() {
        let modelsPyFile = FileManager
                            .documentsDirecotry
                            .appendingPathComponent(name, isDirectory: true)
                            .appendingPathComponent("api", isDirectory: true)
                            .appendingPathComponent("admin.py", isDirectory: false)
        
        do {
            try generateAdminPyFileString().write(toFile: modelsPyFile.path, atomically: true, encoding: String.Encoding.utf8)
        } catch {
            print(error)
        }
    }
}

extension FileManager {
    
    static internal var djangoBuddyDirectory: URL {
        guard let directory = Bundle.module.path(forResource: "DjangoBuddy", ofType: nil) else {
            fatalError("DjangoBuddy resource not found.")
        }
        
        guard let directoryUrl = URL(string: directory) else {
            fatalError("DjangoBuddy directory is not a valid URL.")
        }
        
        return directoryUrl
    }
    
    static internal var documentsDirecotry: URL {
        let paths = NSSearchPathForDirectoriesInDomains(.documentDirectory, .userDomainMask, true)
        let documentsDirectory = paths[0]
        
        guard let docURL = URL(string: documentsDirectory) else {
            fatalError("Coudl't locate the documents direcotry.")
        }
        
        return docURL
    }

    internal func copyFiles(from sourceFile: URL, to destinationUrl: URL) throws {
        try FileManager.default.copyItem(atPath: sourceFile.absoluteString, toPath: destinationUrl.absoluteString)
    }

}
